<!--
    The Lewis Playground
    --------------------------------------
    This web application allows users to visualize and interact with Lewis dot structures
    and VSEPR models for molecules. It supports both 2D and 3D visualization, periodic table
    input, and user-driven model construction and validation.

    Author: Ria Agarwal
    Last Modified: 6/3/2025
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vesper</title>
    <!--other files must be in static folder for it to work in google console-->
    <script src="{{ url_for('static', filename='cytoscape.min.js') }}"></script>
    <script src="{{ url_for('static', filename='interact.min.js') }}"></script>
    <script src="{{ url_for('static', filename='3Dmol-min.js') }}"></script>
    <!--all css code here-->
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2c3e50;
            color: #f1f5f9;
            margin: 0;
            padding: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }
      
        .container {
            background: transparent;
            padding: 2rem;
            border-radius: 1rem;
            width: 100%;
            max-width: 1300px;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            position: relative;
            z-index: 2;
        }
      
        .top-row, .bottom-row {
          display: flex;
          flex-wrap: wrap;
          gap: 2rem;
          justify-content: space-between;
        }
      
        h1 {
          font-size: 3rem;
          color: #38bdf8;
          margin-bottom: 0.5rem;
        }
      
        .form-container {
          flex: 1;
          min-width: 300px;
        }
      
        .form-container p {
          color: #cbd5e1;
          font-size: 1rem;
          margin: 0.5rem 0;
        }
      
        label {
          font-weight: 600;
          margin-top: 1rem;
          display: block;
          margin-bottom: 0.25rem;
        }
      
        input[type="text"] {
          width: 100%;
          padding: 0.75rem;
          border-radius: 0.5rem;
          border: none;
          background-color: #334155;
          color: #f1f5f9;
          margin-bottom: 1rem;
        }
      
        button {
          padding: 0.75rem 1.5rem;
          background-color: #38bdf8;
          color: #0f172a;
          font-weight: 600;
          border: none;
          border-radius: 0.5rem;
          cursor: pointer;
          transition: 0.3s ease;
        }
      
        button:hover {
          background-color: #0ea5e9;
        }
      
        .output-container {
          flex: 1;
          min-width: 300px;
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 1rem;
        }

        .cy {
          width: 100%;
          max-width: 500px;
          height: 500px;
          border: 2px solid #38bdf8;
          border-radius: 1rem;
          background-color: #f8fafc;
        }

        .toolbox-container {
            flex: 1;
            height: 800px;
            padding: 1rem;
            background-color: #506172;
            border-radius: 1rem;
            gap: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }

        .draggable {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #0ea5e9;
            color: #fff;
            font-weight: bold;
            display: flex;
            flex-shrink: 0;
            align-items: center;
            justify-content: center;
            cursor: grab;
        }

        #searchBar {
            width: 100%;
            padding: 0.5rem;
            font-size: 1rem;
            border: none;
            border-radius: 0.5rem;
            background-color: #1e293b;
            color: #f1f5f9;
        }

        .toolbox {
            flex-direction: column;
            overflow-y: auto;
            gap: 0.5rem;
            display: flex;
            padding-right: 0.5rem;
        }

        #lonePair{
            width: 10px;
            height: 10px;
            background-color: #ffcccb;
        }
      
        .periodic-table {
          display: grid;
          grid-template-columns: repeat(18, 1fr);
          gap: 0.4rem;
          margin-bottom: 1rem;
        }
      
        .element {
          width: 40px;
          height: 40px;
          background-color: #3b82f6;
          color: #fff;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 0.375rem;
          font-weight: 600;
          transition: background-color 0.2s ease;
        }
      
        .element:hover {
          background-color: #2563eb;
        }
      
        .element-buttons {
          display: flex;
          gap: 0.25rem;
          justify-content: center;
          align-items: center;
        }
      
        .element-button {
          width: 10px;
          height: 10px;
          background-color: #f43f5e;
          color: #fff;
          border-radius: 50%;
          font-size: 0.5rem;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
        }

        .placeholder {
            width: 40px;
            height: 40px;
            visibility: hidden;
        }

        .skewed {
            position: absolute;
            top: 0;
            bottom: 0;
            right: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background: #0f172a;
            z-index: 0;
            transform: skewY(6deg);
            transform-origin: top right;
        }

        #inp2, #type2 {
            background-color: #506172;
        }

        #next, #back {
            display: none;
        }

        #mol3d{
            width: 500px;
            height: 500px;
            position: relative;
            display: none;
            border: 2px solid #38bdf8;
            border-radius: 1rem;
            background-color: #f8fafc;
            overflow: hidden; 
        }
      </style>
      
</head>
<body>
    <section>
        <div class="skewed"></div>
      </section>
    <div class = "container">
        <!-- Top row with form and output -->
        <div class = "top-row">
            <div class = "form-container">
                <h1>The Lewis Playground</h1>
                <p>Welcome to The Lewis Playground</p>
                <br>
                <p>We use a combinatorics algorithm to solve what the Lewis Dot Structure of a molecule will look like. Note that this doesn't support all molecules yet.<br> Try it out!</p>
                <p>You can enter the molecule name here or use the buttons on the periodic table below</p>
                <form id="wcspForm">
                    <label for="type">Bond type:</label>
                    <input type="text" id="type" name="type" required>
                    <label for="inp">Molecule name (eg. H2O, NaCl):</label>
                    <input type="text" id="inp" name="inp" required>
                    <button type="submit">Submit</button>
                </form>
            </div>
            <div class = "output-container">
                <div id="output"> </div>
                <div id="view-toggle-buttons">
                    <button id="toggleView">Switch to 3d View</button>
                </div>
                <div class = "cy" id="lcy" ></div>
                <div id="mol3d"></div>
                <div>
                    <button type="submit" id="back">Back</button>
                    <button type="submit" id="next">Next</button>
                </div>
            </div>
        </div>
        <div>
            <div class = "periodic-table" id="periodicTable"></div>
            <br>
            <h1>Try It Yourself</h1>
        </div>
        <!-- Bottom row with toolbox and manual output -->
        <div class = "bottom-row">
            <div class = "output-container">
                <div class = "cy" id="mcy" ></div>
                <button id="undoButton">Undo</button>
                <label for="try">Model attempted:</label>
                <form id="checkForm">
                    <label for="inp">Model attempted:</label>
                    <input type="text" id="inp2" name="inp" required>
                    <br>
                    <label for="type">Bond type:</label>
                    <input type="text" id="type2" name="type" required>
                    <button type="check">Check</button>
                </form>
                <div id="checkOutput"></div>
            </div>
            <div class = "toolbox-container">
                <h2>Toolbox</h2>
                    <input type="text" id="searchBar" placeholder="Search...">
                    <div class="toolbox"></div>
                    <div class = "draggable" id="lonePair" data-type="lonePair">l</div>
            </div>
        </div>
        <div id="moleculeInfo"></div>
    </div>

    <script>
        // Main event handler for molecule submission and graph rendering
        document.getElementById('wcspForm').addEventListener('submit', function(event) {
            event.preventDefault();
            const formData = new FormData(this);
            const moleculeName = formData.get('inp');
            fetchMoleculeInfo(moleculeName);

            // Reset output, buttons for multi solutions, and remove dynamically created graph divs except mcy and lcy
            document.getElementById('output').textContent = '';
            document.querySelectorAll('.output-container .cy:not(#mcy):not(#lcy)').forEach(div => div.remove());
            let graphs = [];
            let currentIndex = 0;
            const nextBtn = document.getElementById('next');
            const backBtn = document.getElementById('back');
            const newNextBtn = nextBtn.cloneNode(true);
            const newBackBtn = backBtn.cloneNode(true);
            nextBtn.replaceWith(newNextBtn);
            backBtn.replaceWith(newBackBtn);
            newNextBtn.style.display = "none";
            newBackBtn.style.display = "none";
            // document.getElementById("mol3d").style.display = "none";
            document.getElementById("lcy").style.display = "block";
            document.getElementById("toggleView").textContent = "Switch to 3D View";

            // Fetch and process molecule data from backend
            fetch('/run_code', {
                method: 'POST',
                body: formData,
                headers: {
                    'Accept': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok: ' + response.statusText);
                }
                return response.json();
            })
            .then(data => {
                // Parse backend response for graph solutions
                console.log('Data received from server:', data);
                if (!data || !data.elements || !data.output) {
                    throw new Error('Invalid data received from server');
                }
                const num_vars = data.num_vars;
                const outputString = String(data.output);
                const outputs = outputString.match(/(\d+ solution\(0\):\s+[\d\s]+)/g);
                const elements = renameDuplicates(data.elements);
                const central = data.centrals;
                let graphs = [];
                let currentIndex = 0;
                
                // Parse up to 3 solutions and build graph objects
                outputs.slice(0, 3).forEach((output, index) => {
                    const input = output.match(/solution\(0\):\s+([\d\s]+)/)[1];
                    text = `Solution ${index + 1}: ${output}\n`;
                    console.log(text);
                    console.log('Parsed input:', input);
                    let graph;
                    console.log('Elements:', elements);
                    // Separate logic for single-center and multi-center molecules
                    if (central == 1){
                        graph = parseInputOG(input, num_vars, elements);
                    } else {
                        graph = parseInputNew(input, num_vars, elements, central);
                    }
                    graphs.push(graph);
                });

                // Enable navigation buttons if multiple solutions exist
                if (graphs.length > 1){
                    newNextBtn.style.display = "inline";
                    newBackBtn.style.display = "inline";
                }

                // Displays the cytoscape graph based on the current index
                function updateGraph(){
                    const container = document.getElementById('lcy');
                    console.log('Updating graph with elements:', graphs[currentIndex].nodes);
                    var cy = cytoscape({
                        container: container,
                        elements: graphs[currentIndex].nodes.concat(graphs[currentIndex].edges),
                        // Define the style for nodes and edges
                        style: [
                            {
                                selector: 'node',
                                style: {
                                    'label': 'data(label)',
                                    'background-color': '#61bffc',
                                    'text-valign': 'center',
                                    'text-halign': 'center',
                                    'shape': 'ellipse',
                                    'width': 40,
                                    'height': 40,
                                    'font-size': 12,
                                    'border-width': 2,
                                    'border-color': '#333'
                                }
                            },
                            {
                                selector: 'edge',
                                style: {
                                    'label': 'data(label)',
                                    'line-color': '#ccc',
                                    'width': 3,
                                    'target-arrow-shape': 'triangle',
                                    'target-arrow-color': '#ccc',
                                    'curve-style': 'bezier',
                                    'text-margin-y': -10,
                                    'font-size': 10,
                                }
                            },
                            {
                                selector: 'node[label="l"]',
                                style: {
                                    'background-color': '#ffcccb', 
                                    'width': 10,
                                    'height': 10,
                                    'shape': 'ellipse'
                                }
                            },
                            {
                                selector: 'edge[label=""]',
                                style: {
                                    'line-color': 'transparent',
                                    'width': 3,
                                    'target-arrow-shape': 'none',
                                    'line-opacity': 0
                                }
                            }
                        ],
                        layout: {
                            name: 'preset',      
                        }
                    });
                }

                updateGraph();

                // Navigation button event handlers for multi-solution graphs
                newNextBtn.addEventListener('click', function () {
                    if (currentIndex < graphs.length - 1){
                        currentIndex++;
                        updateGraph();
                    }
                });

                newBackBtn.addEventListener('click', function () {
                    if (currentIndex > 0){
                        currentIndex--;
                        updateGraph();
                    }
                });

                // 2D/3D View Toggle Handler
                let is3DView = false;
                document.getElementById("toggleView").addEventListener("click", ()=> {
                    const cyDiv = document.getElementById("lcy");
                    const molDiv = document.getElementById("mol3d");
                    const toggleBtn = document.getElementById("toggleView");
                    if (is3DView) {
                        molDiv.style.display = "none";
                        cyDiv.style.display = "block";
                        toggleBtn.textContent = "Switch to 3D View";
                    } else {
                        cyDiv.style.display = "none";
                        molDiv.style.display = "block";
                        render3DMolecule(graphs[currentIndex].nodes, graphs[currentIndex].edges);
                        toggleBtn.textContent = "Switch to 2D View";
                    }
                    is3DView = !is3DView;
                });

                // Store the first graph for validation
                window.firstGraph = graphs[0];
            })
            .catch((error) => {
                console.error('Error occurred:', error);
                document.getElementById('output').textContent = 'Error: ' + error.message;
            });
        });

        // Renders a 3D molecule using 3Dmol.js and takes nodes and edges as input for the position and label of atoms
        function render3DMolecule(nodes, edges) {
            const viewer = $3Dmol.createViewer("mol3d", {
                backgroundColor: "white"
            });
            viewer.clear();

            const atomNodes = nodes.filter(n => n.data.label !== 'l');

            const xyzAtoms = atomNodes.map(n => {
                let label = n.data.label;
                if (typeof label !== 'string') {
                    console.warn("Unexpected label type:", label, "in node", n);
                    label = String(label); 
                }

                label = label.replace(/\d+$/, '');
                const x = n.position.x / 100;
                const y = n.position.y / 100;
                const z = 0;
                return `${label} ${x} ${y} ${z}`;
            });

            console.log("atomNodes", atomNodes);
            
            const xyzData = `${xyzAtoms.length}\nGenerated from graph\n` + xyzAtoms.join('\n');

            viewer.addModel(xyzData, "xyz");
            viewer.setStyle({}, {stick: {}, sphere: {scale: 0.3}});
            viewer.zoomTo();
            viewer.render();
        }

        // Renames duplicates elements in a list by appending a count and takes the list of element symbols as input
        // Returns a new list with duplicates renamed
        function renameDuplicates(list) {
            const result = [];
            const counts = {};

            for (const element of list) {
                if (counts[element]) {
                    counts[element]++;
                    result.push(`${element}${counts[element]}`);
                } else {
                    counts[element] = 1;
                    result.push(element);
                }
            }
            return result;
        }

        // Parses the input string for a single-center molecule and builds a graph structure with nodes and edges
        // Takes the input string, number of variables, and a list of element symbols as parameters
        function parseInputOG(input, num_vars, elements) {
            let values = input.substring(0, num_vars*2);
            console.log(values);
            let numVals = values.split(' ').map(Number);
            console.log(numVals);
            let lonePairs = numVals.slice(0, elements.length);
            console.log(lonePairs);
            let bonds = numVals.slice(elements.length);
            console.log(bonds);
            
            let nodes = [];
            let edges = [];
            let lonePairCounter = 0;

            // Defines starting center
            let centerX = 450;
            let centerY = 250;
            let x = 0;
            let y = 0;
            
            count = 0;
            for (let i = 0; i < bonds.length; i++) {
                if (bonds[i] > 0){
                    count++;
                }
            }

            if (lonePairs[0] > 0){
                count++;
            }

            // Calculate the bond angle based on the number of elements
            let bondAngle;
            if (count === 0) {
                bondAngle = 0; // Avoid division by zero
            } else {
                bondAngle = (2 * Math.PI) / count;
            }
            console.log(bondAngle);

            for (let i = 0; i < elements.length; i++) {
                let angle = i * bondAngle;
                console.log(angle)
                x = i == 0 ? centerX : centerX + 120 * Math.cos(angle);
                y = i == 0 ? centerY : centerY + 120 * Math.sin(angle);

                // Places nodes in position
                nodes.push({
                    data: {
                        id: elements[i],
                        label: elements[i]
                    },
                    position: {
                        x: x,
                        y: y
                    }
                });

                // Places lone pairs around the node
                let lonePairAngleStep = (2 * Math.PI) / lonePairs[i];
                for (let j = 0; j < lonePairs[i]; j++) {
                    let angle = j * lonePairAngleStep; 
                    let offsetX = 20 * Math.cos(angle); 
                    let offsetY = 20 * Math.sin(angle);
                    lonePairCounter++;

                    const lonePairID = lonePairCounter > 1 ? `lonePair${lonePairCounter}` : 'lonePair';
                    console.log("hi!");

                    nodes.push({
                        data: {
                            id: lonePairID,
                            label: "l"
                        },
                        position: {
                            x: x + offsetX,
                            y: y + offsetY
                        }
                    });

                    edges.push({
                        data: {
                            source: elements[i],
                            target: lonePairID,
                            label: '',
                        }
                    });
                }
            }
                
            // Creates edges based on bonds
            console.log(nodes);
            let bondIndex = 0;
            for (let i = 0; i < elements.length; i++) {
                for (let j = i + 1; j < elements.length; j++) {
                    let bond = bonds[bondIndex];
                    bondIndex++;
                    if (bond > 0) {
                        edges.push({
                            data: {
                                source: elements[i],
                                target: elements[j],
                                label: bond === 2 ? 'Single Bond' : bond === 4 ? 'Double Bond' : 'Triple Bond'
                            }
                        });
                    }
                }
            }
            console.log(edges);
            return { nodes, edges };
        }

        let gridOffsets = [
            { x: 100, y: 0 },   // right
            { x: 0, y: 100 },   // down
            { x: -100, y: 0 },  // left
            { x: 0, y: -100 }   // up
        ];
        
        // Parses input string for multi-center molecules and builds a graph structure with nodes and edges
        // Takes the input string, number of variables, a list of element symbols, and the number of central atoms as parameters
        function parseInputNew(input, num_vars, elements, central) {
            let values = input.substring(0, num_vars * 2);
            console.log(values);
            let numVals = values.split(' ').map(Number);
            console.log(numVals);
            let lonePairs = numVals.slice(0, elements.length);
            console.log(lonePairs);
            let bonds = numVals.slice(elements.length);
            console.log(bonds);
            
            let nodes = [];
            let edges = [];
            let usedPositions = [];
            let lonePairCounter = 0;
            let centerX = 450;
            let centerY = 250;
            let centers = [];
            let lastCenter = 0;
            let x = 0;
            let y = 0;
            let bondNum = 1;
            let bondInc = 1;

            //Places just the central atoms
            for (let i = 0; i < elements.length; i++){
                if (elements[i].substring(0, 1) === elements[0]) {
                    x = centerX + i * (100) * (-1)**(i);
                    if ((-1)**(i) > 0 && i != 0){
                        x  -= 100;
                    }
                    y = centerY;
                    centers.push(x);
                    lastCenter ++;
                    nodes.push({
                        data: {
                            id: elements[i],
                            label: elements[i]
                        },
                        position: {
                            x: x,
                            y: y
                        }
                    });
                    usedPositions.push({ x, y });
                }
            }
            console.log(usedPositions);

            // Finds which central atom each element is bonded to
            for (let i = lastCenter; i < elements.length; i++) {
                for (let j = 0; j < lastCenter; j++) {
                    let bond = bonds[bondNum];
                    bondNum += elements.length - 1;
                    if (bond > 0) {
                        let centerX = centers[j];
                        centers.push(centerX);
                    }
                }
                bondInc++;
                bondNum = bondInc;
            }
            
            console.log(centers);

            // Creates a map of which elements each central atom is bonded to
            let centerBondMap = {};
            let bondInd = 1;

            for (let i = 0; i < lastCenter; i++) {
                centerBondMap[i] = []; 
                for (let j = lastCenter; j < elements.length; j++) {
                    if (bonds[bondInd] > 0) {
                        centerBondMap[i].push(j);
                    }
                    bondInd++;
                }
            }
            console.log(centerBondMap);

            // Finds which is the leftmost central atom
            let min = centers[0];
            for (let i = 0; i < centers.length; i++) {
                if (centers[i] < min){
                    min = centers[i];
                }
            }

            let angle = 0;
            for (let centerIdx = 0; centerIdx < lastCenter; centerIdx++) {
                let bonded = centerBondMap[centerIdx];
                let numBonds = bonded.length;
                // Places each atom at 90 degree angle increments from the center atom
                let angleStep = (2 * Math.PI) / 4;
                let l = 1;
                for (let k = 0; k < numBonds; k++) {
                    // Adjusts the angle based on the number of bonds and the position of the center atom
                    if (numBonds ==2){
                        angle = (k+l) * angleStep;
                        l++;
                    } else if (numBonds == 1 && centers[centerIdx] == min){
                        angle = (k+2) * angleStep;
                    } else {
                        angle = k * angleStep;
                    }
                    let bondedIdx = bonded[k];
                    let x = centers[centerIdx] + 120 * Math.cos(angle);
                    let y = centerY + 120 * Math.sin(angle);
                    x = Math.round(x / 50) * 50;
                    y = Math.round(y / 50) * 50;

                    // Checks if the position is occupied, and if so, finds a new position by incrementing the angle
                    let m = k;
                    while (positionOccupied(x, y, usedPositions)) {
                        m++;
                        angle = m * angleStep;
                        x = centers[centerIdx] + 120 * Math.cos(angle);
                        y = centerY + 120 * Math.sin(angle);
                        x = Math.round(x / 50) * 50;
                        y = Math.round(y / 50) * 50;
                    }
                    usedPositions.push({ x, y });
                    console.log(usedPositions);

                    // Places the nodes of elements
                    nodes.push({
                        data: {
                            id: elements[bondedIdx],
                            label: elements[bondedIdx]
                        },
                        position: { x, y }
                    });
                }
            }
        
            // Places the lone pairs around the nodes
            for (let i = 0; i < elements.length; i++) {
                let lonePairAngleStep = (2 * Math.PI) / lonePairs[i];
                for (let j = 0; j < lonePairs[i]; j++) {
                    let angle = j * lonePairAngleStep; 
                    let offsetX = 20 * Math.cos(angle); 
                    let offsetY = 20 * Math.sin(angle);
                    lonePairCounter++;

                    const lonePairID = lonePairCounter > 1 ? `lonePair${lonePairCounter}` : 'lonePair';

                    nodes.push({
                        data: {
                            id: lonePairID,
                            label: "l"
                        },
                        position: {
                            x: usedPositions[i].x + offsetX,
                            y: usedPositions[i].y + offsetY
                        }
                    });

                    edges.push({
                        data: {
                            source: elements[i],
                            target: lonePairID,
                            label: '',
                        }
                    });
                }
            }
                
            // Creates edges based on bonds
            console.log(nodes);
            let bondIndex = 0;
            for (let i = 0; i < elements.length; i++) {
                for (let j = i + 1; j < elements.length; j++) {
                    let bond = bonds[bondIndex];
                    bondIndex++;
                    if (bond > 0) {
                        edges.push({
                            data: {
                                source: elements[i],
                                target: elements[j],
                                label: bond === 2 ? 'Single Bond' : bond === 4 ? 'Double Bond' : 'Triple Bond'
                            }
                        });
                    }
                }
            }
            console.log(edges);
            return { nodes, edges, centers, lastCenter, bonds };
        }

        // Checks if a position is occupied by comparing it to the used positions
        // Takes the x and y coordinates and the used positions array as parameters
        // Returns true if the position is occupied, false otherwise
        function positionOccupied(x, y, usedPositions) {
            return usedPositions.some(pos => pos.x === x && pos.y === y);
        }

        // Cytoscape setup for user-drawn model
        const idCounts = {};
        const actionHistory = [];
        const cy = cytoscape({
            container: document.getElementById('mcy'),
            elements: [],
            style: [
                {
                    selector: 'node',
                    style: {
                        'label': 'data(label)',
                        'background-color': '#61bffc',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'shape': 'ellipse',
                        'width': 40,
                        'height': 40,
                        'font-size': 12,
                    },
                },
                {
                    selector: 'edge',
                    style: {
                        'line-color': '#ccc',
                        'width': 3,
                        'target-arrow-shape': 'triangle',
                        'target-arrow-color': '#ccc',
                        'curve-style': 'bezier',
                    },
                },
                {
                            selector: 'node[label="l"]',
                            style: {
                                'background-color': '#ffcccb', 
                                'width': 10,
                                'height': 10,
                                'shape': 'ellipse'
                            }
                        },
                        {
                            selector: 'edge[label=""]',
                            style: {
                                'line-color': 'transparent',
                                'width': 3,
                                'target-arrow-shape': 'none',
                                'line-opacity': 0
                            }
                        }
            ],
            layout: {
                name: 'preset',
            },
        });

        let allElements = [];

        // Fetches the periodic table data
        fetch('{{url_for("static", filename="periodic_table.json")}}')
            .then(response => response.json())
            .then(data => {
                allElements = data;
                displayElements(allElements);
                createPeriodicTable();
            })
            .catch(error => console.error('Error loading toolbox or periodic table:', error));

            // Creates elements in the toolbox nd initializes drag  and drop functionality
            // Takes an array of elements as input
        function displayElements(elements){
            document.querySelector('.toolbox').innerHTML = "";
            elements.forEach(element => {
                const div = document.createElement("div");
                div.classList.add("draggable");
                div.id = element.symbol;
                div.textContent = div.id;
                div.setAttribute("data-type", element.symbol);
                document.querySelector('.toolbox').appendChild(div);
                initializeDrag();
            });
        }

        // Showcases elements when searched for
        document.getElementById("searchBar").addEventListener("input", () =>{
                const search = searchBar.value.toLowerCase();
                const filteredElements = allElements.filter(el =>
                    el.name.toLowerCase().startsWith(search)
                );
                displayElements(filteredElements);
        });

        // Initializes drag and drop functionality for toolbox elements
        function initializeDrag(){
            interact('.draggable').draggable({
                inertia: true,
                modifiers: [
                    interact.modifiers.restrictRect({
                    restriction: document.body, 
                    endOnly: true 
                    })
                ],
                listeners: {
                    move: dragMoveListener,
                    end (event) {
                        const element = event.target;
                        element.removeAttribute('data-x');
                        element.removeAttribute('data-y');
                        element.style.transform = 'translate(0, 0)';
                    }
                }
            })
        }

        // Handles the drag movement of elements and takes the event as input
        // Updates the position of the dragged element based on the drag event
        function dragMoveListener(event) {
            const target = event.target;
            const x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
            const y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

            target.style.transform = `translate(${x}px, ${y}px)`;
            target.setAttribute('data-x', x);
            target.setAttribute('data-y', y);
        }

        initializeDrag();

        // Sets up the dropzone for the cytoscape container
        interact('#mcy').dropzone({
            accept: '.draggable',
            ondrop: function (event) {
                const cyRect = document.getElementById('mcy').getBoundingClientRect();
                const element = event.relatedTarget;
                const baseId = element.id;

                if (!idCounts[baseId]){
                    idCounts[baseId] = 1;
                } else {
                    idCounts[baseId] += 1;
                }
                console.log(idCounts);
                const id = idCounts[baseId] > 1 ? `${baseId}${idCounts[baseId]}` : baseId;

                cy.add({
                    data: { id, label: id.includes("lonePair") ? "l" : element.id },
                    position: {
                        x: event.dragEvent.clientX - cyRect.left,
                        y: event.dragEvent.clientY - cyRect.top,
                    },
                });
                actionHistory.push({action: 'addNode', id: id});
            },
        });

        let selectedNode = null;

        // Handles the tap event on nodes to select them and create edges
        cy.on('tap', 'node', function (evt) {
            const node = evt.target;

            if (!selectedNode) {
                selectedNode = node;
                node.style('background-color', '#ff5733');
            } else {
                cy.add({
                    group: 'edges',
                    data: {
                        id: `${selectedNode.id()}_${node.id()}`,
                        source: selectedNode.id(),
                        target: node.id(),
                        label: node.id().includes("lonePair") ? '' : null
                    },
                });
                
                actionHistory.push({action: 'addEdge', id: `${selectedNode.id()}_${node.id()}`});
                selectedNode.style('background-color', '#61bffc');
                selectedNode = null;
            }
        });

        // Deselects the node when clicking outside of it
        cy.on('tap', function (event) {
            if (event.target === cy && selectedNode) {
                selectedNode.style('background-color', '#61bffc');
                selectedNode = null;
            }
        });

        // Handles the undo button to remove the last action performed
        document.getElementById("undoButton").addEventListener("click", ()=> {
            if (actionHistory.length > 0){
                const lastAction = actionHistory.pop();
                cy.remove(cy.getElementById(lastAction.id));
            }
        });

        // Updates the input field based on the periodic table button add or subtract
        // Takes the element symbol and action as parameters
        function updateInput(elementSymbol, action) {
            const input = document.getElementById("inp");
            let value = input.value;
            const regex = new RegExp(`(${elementSymbol})(\\d*)`);
            const match = value.match(regex);

            // increases/decreases count if it is the same element
            if (action === "add") {
                if (match) {
                    const count = parseInt(match[2] || "1") + 1;
                    value = value.replace(regex, `${elementSymbol}${count}`);
                } else {
                    value += elementSymbol;
                }
            } else if (action === "subtract") {
                if (match) {
                    const count = parseInt(match[2] || "1") - 1;
                    if (count > 1) {
                        value = value.replace(regex, `${elementSymbol}${count}`);
                    } else if (count === 1) {
                        value = value.replace(regex, elementSymbol);
                    } else {
                        value = value.replace(regex, "");
                    }
                }
            }

            input.value = value;
        }

        // fetches the molecule information from PubChem API and displays it
        // Takes the molecule name as input
        function fetchMoleculeInfo(molecule) {
            fetch(`https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/${molecule}/JSON`)
                .then(response => response.json())
                .then(data => {
                    if (!data.PC_Compounds || data.PC_Compounds.length === 0) {
                        throw new Error('No compound data found');
                    }
                    const compound = data.PC_Compounds[0];

                    const getProperty = (label) => {
                        const property = compound.props.find(prop => prop.urn.label === label);
                        return property ? property.value.sval || property.value.fval || "N/A" : "N/A";
                    };

                    const molecularFormula = getProperty("Molecular Formula");
                    const molecularWeight = getProperty("Molecular Weight");
                    const iupacName = getProperty("IUPAC Name");
                    
                    document.getElementById('moleculeInfo').innerHTML = `
                        <h3>Molecule Information</h3>
                        <p><strong>Molecular Formula:</strong> ${molecularFormula}</p>
                        <p><strong>Molecular Weight:</strong> ${molecularWeight} g/mol</p>
                        <p><strong>IUPAC Name:</strong> ${iupacName}</p>
                    `;
                })
                .catch(error => {
                    console.error('Error fetching molecule info:', error);
                    document.getElementById('moleculeInfo').textContent = 'Error fetching molecule info: ' + error.message;
                });
            }

        // User model validation and comparison logic
        document.getElementById("checkForm").addEventListener('submit', function (event) {
            event.preventDefault();
            const formData = new FormData(this);
            const moleculeName = formData.get('inp');
            // Run backend code to fetch the expected graph
            fetchMoleculeInfo(moleculeName);
            fetch('/run_code', {
                method: 'POST',
                body: formData,
                headers: {
                    'Accept': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok: ' + response.statusText);
                }
                return response.json();
            })
            .then(data => {
                // Parse the response data to get the expected graph structure
                const num_vars = data.num_vars;
                const outputString = String(data.output);
                const central = data.centrals;
                const elements = renameDuplicates(data.elements);
                const outputs = outputString.match(/(\d+ solution\(0\):\s+[\d\s]+)/g);
                const input = outputs[0].match(/solution\(0\):\s+([\d\s]+)/)[1]; // Extract the first solution input
                if (central == 1){
                    graph = parseInputOG(input, num_vars, elements);
                } else {
                    graph = parseInputNew(input, num_vars, elements, central);
                }
                const theirGraph = getCytoscapeGraph();
                const validation = validateGraph(theirGraph, graph);
                document.getElementById('checkOutput').textContent = validation
                    ? 'Graph matches the expected model!'
                    : 'Graph does not match the expected model.';
            })
            .catch(error => {
                console.error('Error occurred:', error);
                document.getElementById('checkOutput').textContent = 'Error: ' + error.message;
            });
        });

        // Validates the user drawn graph against the expected graph
        // Takes the user drawn graph and the expected graph as parameters
        function validateGraph(theirGraph, graph) {
            const nodesMatch = validateNodes(theirGraph.nodes, graph.nodes);
            const edgesMatch = validateEdges(theirGraph.edges, graph.edges);

            return nodesMatch && edgesMatch;
        }

        // Validates the nodes and edges of the user drawn graph against the expected graph
        // Takes the user drawn nodes  and the expected nodes as parameters
        function validateNodes(nodes, expectedNodes) {
            console.log(nodes);
            console.log(expectedNodes);
            if (nodes.length !== expectedNodes.length) return false;
            const nodeIds = nodes.map(node => node.id);
            console.log(nodeIds);
            console.log(expectedNodes.every(expected => nodeIds.includes(expected.data.id)));
            return expectedNodes.every(expected => nodeIds.includes(expected.data.id));
        }

        // Validates the edges of the user drawn graph against the expected graph
        // Takes the user drawn edges and the expected edges as parameters
        function validateEdges(edges, expectedEdges) {
            console.log(edges);
            console.log(expectedEdges);
            if (edges.length !== expectedEdges.length) return false;
            const edgePairs = edges.map(edge => `${edge.source}-${edge.target}`);
            const expectedPairs = expectedEdges.map(expected => `${expected.data.source}-${expected.data.target}`);
            console.log(edgePairs);
            console.log(expectedPairs);
            return expectedPairs.every(pair => edgePairs.includes(pair));
        }

        // Gets the Cytoscape graph structure
        function getCytoscapeGraph() {
            const nodes = cy.nodes().map(node => ({
                id: node.data('id'),
                label: node.data('label'),
                position: node.position()
            }));

            const edges = cy.edges().map(edge => ({
                source: edge.data('source'),
                target: edge.data('target'),
                label: edge.data('label')
            }));

            return { nodes, edges };
        }

        const periodicTableData = [
            ["H", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "He"],
            ["Li", "Be", "", "", "", "", "", "", "", "", "", "", "B", "C", "N", "O", "F", "Ne"],
            ["Na", "Mg", "", "", "", "", "", "", "", "", "", "", "Al", "Si", "P", "S", "Cl", "Ar"],
            ["K", "Ca", "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr"],
            ["Rb", "Sr", "Y", "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb", "Te", "I", "Xe"],
            ["Cs", "Ba", "", "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi", "Po", "At", "Rn"],
            ["Fr", "Ra", "", "Rf", "Db", "Sg", "Bh", "Hs", "Mt", "Ds", "Rg", "Cn", "Nh", "Fl", "Mc", "Lv", "Ts", "Og"],
            ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""],
            ["", "", "La", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb", "Lu", ""],
            ["", "", "Ac", "Th", "Pa", "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No", "Lr", ""]
        ];

        // Creates and displays the periodic table based on the data and rendering above using a grid
        function createPeriodicTable() {
            const periodicTable = document.getElementById("periodicTable");
            periodicTable.innerHTML = "";
            periodicTableData.forEach((row, rowIndex) => {
                row.forEach((symbol, colIndex) => {
                    if (symbol === ""){
                        const placeholder = document.createElement("div");
                        placeholder.classList.add("placeholder");
                        placeholder.style.gridColumn = colIndex + 1;
                        periodicTable.appendChild(placeholder);
                        return;
                    }
                    const div = document.createElement("div");
                    div.classList.add("element");
                    div.id = symbol;
                    div.style.gridColumn = colIndex + 1;
                    div.innerHTML = `
                        <div>
                            <div class="element-buttons">
                                <div class="element-button" data-action="add">+</div>
                                <div class="element-button" data-action="subtract">-</div>
                            </div>
                            <div>${symbol}</div>
                        </div>
                    `;
                    periodicTable.appendChild(div);
                })
            })
        }

        // Handles clicking in the periodic table to add or subtract elements into the input field
        document.getElementById("periodicTable").addEventListener("click", function(event) {
            if (event.target.classList.contains("element-button")) {
                const elementSymbol = event.target.closest('.element').id;
                const action = event.target.dataset.action;
                updateInput(elementSymbol, action);
            } else if (event.target.classList.contains("element")) {
                const elementSymbol = event.target.id;
                updateInput(elementSymbol, "add");
            }
        });
    </script>  
</body>
</html>